name: 'Update Jira keys for release'
description: 'Update Jira keys for release'
inputs:
  client-id:
    description: 'Client ID'
    required: true
    type: string
  client-secret:
    description: 'Client secret'
    required: true
    type: string
  ghRepository:
    description: 'GitHub repository in format org/repo'
    required: true
    type: string
  jiraBaseUrl:
    description: 'Jira base URL'
    default: 'https://virtocommerce.atlassian.net'
    required: true
    type: string
  jiraCustomFieldId:
    description: 'Jira custom field ID to update'
    required: true
    type: string
  jiraCustomFieldValue:
    description: 'Jira custom field value to set'
    required: true
    type: string
# outputs:
#   jira-keys:
#     description: 'Jira keys that were found in branch names between previous and last release in comma delimited format'
  
runs:
  using: "composite"
  steps:       
    - name: Process Jira keys
      shell: pwsh
      env:
        # GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        JIRA_USER: ${{ inputs.client-id }}
        JIRA_TOKEN: ${{ inputs.client-secret }}
      run: |
        $ErrorActionPreference = "Stop"
        $jiraKeys = @()
        $owner, $repo = "${{ inputs.ghRepository }}" -split "/"

        # Get two latest releases
        $releases = gh api "/repos/$owner/$repo/releases" | ConvertFrom-Json
        $releases = $releases | Sort-Object { [datetime]$_.created_at } -Descending
        $currentTag = $releases[0].tag_name
        $prevTag = $releases[1].tag_name
        Write-Host "Comparing $prevTag...$currentTag"

        # Get commits between tags
        $commits = gh api "/repos/$owner/$repo/compare/$prevTag...$currentTag" --jq ".commits[].sha"
        
        foreach ($sha in $commits) {
            $prs = gh api "/repos/$owner/$repo/commits/$sha/pulls" -H "Accept: application/vnd.github.groot-preview+json" | ConvertFrom-Json
            foreach ($pr in $prs) {
                if ($null -ne $pr.head.ref) {
                    if ($pr.head.ref -match '([A-Z]+-\d{1,6})') {
                        $jiraKeys += $matches[1]
                    }
                    else {
                        Write-Warning "Branch $($pr.head.ref) does not match the pattern [A-Z]+-\d{1,6}"
                    }
                }
            }
        }
        
        $uniqueJiraKeys = $jiraKeys | Sort-Object -Unique
        Write-Host "Jira keys merged since last release:"
        $uniqueJiraKeys | ForEach-Object { Write-Host $_ }
        # $jiraKeysOutput = $uniqueJiraKeys -join ','
        # Write-Host "jira-keys=$jiraKeysOutput" >> $GITHUB_OUTPUT

        # Create Jira auth header
        $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes("${env:JIRA_USER}:${env:JIRA_TOKEN}"))
        $headers = @{
            "Authorization" = "Basic $base64AuthInfo"
            "Content-Type"  = "application/json"
        }
        $updateBody = @{
            fields = @{
                "${{ inputs.jiraCustomFieldId }}" = "${{ inputs.jiraCustomFieldValue }}"
            }
        } | ConvertTo-Json -Depth 5

        $uniqueJiraKeys = @('VCST-2609')
        foreach ($jiraKey in $uniqueJiraKeys) {
            Write-Host "Updating $jiraKey"
            $response = Invoke-RestMethod -Uri "${{ inputs.jiraBaseUrl }}/rest/api/3/issue/$jiraKey" -Headers $headers -Method Put -Body $updateBody
            Write-Host "Updated $jiraKey"
        }