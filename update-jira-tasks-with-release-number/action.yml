# This action updates JIRA tasks with release information by:
# 1. Finding the release matching the specified GitHub release tag in ghReleaseTag input
# 2. Finding all commits between that release and the previous release
# 3. Extracting JIRA keys from commit messages (format: [A-Z]{2,}-\d+)
# 4. Updating each JIRA task's custom field with the specified value
# 5. Handling errors gracefully and logging results

name: 'Update Jira tasks with release number'
description: 'Update Jira tasks with release number'
inputs:
  client-id:
    description: 'Client ID'
    required: true
    type: string
  client-secret:
    description: 'Client secret'
    required: true
    type: string
  ghRepository:
    description: 'GitHub repository in format org/repo'
    required: true
    type: string
  ghReleaseTag:
    description: 'GitHub release tag'
    required: true
    type: string
  jiraBaseUrl:
    description: 'Jira base URL'
    default: 'https://virtocommerce.atlassian.net'
    required: true
    type: string
  jiraCustomFieldId:
    description: 'Jira custom field ID to update'
    required: true
    type: string
  jiraCustomFieldValue:
    description: 'Jira custom field value to set'
    required: true
    type: string
  
runs:
  using: "composite"
  steps:       
    - name: Process Jira keys
      shell: pwsh
      env:
        JIRA_USER: ${{ inputs.client-id }}
        JIRA_TOKEN: ${{ inputs.client-secret }}
      run: |
        $ErrorActionPreference = "Stop"
        $jiraKeys = @()
        $owner, $repo = "${{ inputs.ghRepository }}" -split "/"

        $releases = gh api "/repos/$owner/$repo/releases" | ConvertFrom-Json
        $releaseCounter = 0
        $currentReleaseNumber = -1
        while ($releaseCounter -lt $releases.Count) { # Find the release matching the specified GitHub release tag
          if ($releases[$releaseCounter].tag_name -eq "${{ inputs.ghReleaseTag }}") {
            $currentReleaseNumber = $releaseCounter
            break
          }
          $releaseCounter++
        }
        if ($currentReleaseNumber -eq -1) { # If the current release tag is not found, terminate the script
            Write-Warning "Release tag '${{ inputs.ghReleaseTag }}' not found. Terminating..."
          exit 1
        }
        if ($releases.Count -lt 2) { # If there are less than 2 releases, use the last 100 commits
          Write-Warning "Not enough releases found, using the last 100 commits"
          $commits = $(gh api "/repos/$owner/$repo/commits?per_page=100" | ConvertFrom-Json).commit
        } else {
          $currentTag = $releases[$currentReleaseNumber].tag_name
          $prevTag = $releases[$($currentReleaseNumber + 1)].tag_name
          try {
            gh api "/repos/$owner/$repo/releases/tags/$prevTag" | ConvertFrom-Json # Check if the previous release tag exists
          } catch {
            Write-Warning "Previous release tag '$prevTag' not found. Terminating..."
            exit 1
          }
          Write-Host "Comparing $prevTag...$currentTag"
          $commits = $(gh api "/repos/$owner/$repo/compare/$prevTag...$currentTag" | ConvertFrom-Json).commits.commit # Get the commits between the previous and current release tags
        }

        foreach ($commit in $commits) {
          if ($commit.message -match '[A-Z]{2,}-\d+') {
            $jiraKeys += $matches[0]
          }
          else {
            Write-Warning "Commit '$($commit.message)' did not match the pattern [A-Z]{2,}-\d+. Commit URL: $($commit.url)"
          }
        }
        
        if ($jiraKeys.Count -eq 0) {
          Write-Warning "No Jira keys found"
          exit 0
        }

        $uniqueJiraKeys = $jiraKeys | Sort-Object -Unique
        Write-Host "Jira keys merged since last release:"
        $uniqueJiraKeys | ForEach-Object { Write-Host "$_" }

        # Create Jira auth header
        $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes("${env:JIRA_USER}:${env:JIRA_TOKEN}"))
        $headers = @{
            "Authorization" = "Basic $base64AuthInfo"
            "Content-Type"  = "application/json"
        }
        $updateBody = @{
            fields = @{
                "${{ inputs.jiraCustomFieldId }}" = "${{ inputs.jiraCustomFieldValue }}"
            }
        } | ConvertTo-Json -Depth 5

        Write-Host "üîÑ Updating tasks ..."
        foreach ($jiraKey in $uniqueJiraKeys) {
            try {
              $response = Invoke-RestMethod -Uri "${{ inputs.jiraBaseUrl }}/rest/api/3/issue/$jiraKey" -Headers $headers -Method Put -Body $updateBody
              Write-Host "‚úÖ Updated task $jiraKey"
            }
            catch {
              Write-Host "‚ùå Failed to update task $jiraKey. $($_ -replace '\s+', ' ')"
            }
        }
        Write-Host "üéâ Done updating tasks"